/**
 * AudioManager - Modularny zarzƒÖdzanie audio ES6
 * Wersja refaktoryzowana z podzia≈Çem na modu≈Çy
 */

import { AUDIO_CONFIG } from './audio-config.js';
import { 
    SpeechSynthesisEngine, 
    GoogleTTSEngine, 
    ResponsiveVoiceEngine,
    TTSEngineFactory 
} from './tts-engines.js';

/**
 * G≈Ç√≥wna klasa AudioManager
 */
export class AudioManager {
    constructor() {
        this.audioCache = new Map();
        this.isPlaying = false;
        this.autoPlay = false;
        this.volume = AUDIO_CONFIG.defaults.volume;
        this.rate = AUDIO_CONFIG.defaults.rate;
        this.currentAudio = null;
        
        // Silniki TTS
        this.engines = {
            speechSynthesis: null,
            googleTTS: null,
            responsiveVoice: null
        };
        
        // Stan inicjalizacji
        this.isInitialized = false;
        
        console.log('üîä AudioManager (ES6) zainicjalizowany');
    }

    /**
     * Inicjalizacja AudioManager
     */
    async initialize() {
        if (this.isInitialized) {
            console.log('‚ö†Ô∏è AudioManager ju≈º zainicjalizowany');
            return;
        }

        console.log('üîÑ Inicjalizujƒô silniki TTS...');

        try {
            // Inicjalizuj silniki TTS
            this.engines.speechSynthesis = await TTSEngineFactory.createAndInitialize('speechSynthesis');
            this.engines.googleTTS = TTSEngineFactory.createEngine('googleTTS');
            this.engines.responsiveVoice = TTSEngineFactory.createEngine('responsiveVoice');

            this.isInitialized = true;
            console.log('‚úÖ AudioManager w pe≈Çni zainicjalizowany');

            // Wykonaj test po chwili
            setTimeout(() => this.performDelayedTest(), 2000);

        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd inicjalizacji AudioManager:', error);
        }
    }

    /**
     * Test audio z op√≥≈∫nieniem
     */
    async performDelayedTest() {
        try {
            const testResults = await this.testAudio();
            const workingMethods = Object.entries(testResults)
                .filter(([_, works]) => works)
                .map(([method, _]) => method);
                
            if (workingMethods.length > 0) {
                console.log(`‚úÖ Dzia≈ÇajƒÖce metody audio: ${workingMethods.join(', ')}`);
            } else {
                console.warn('‚ö†Ô∏è ≈ªadna metoda audio nie dzia≈Ça - sprawd≈∫ ustawienia przeglƒÖdarki');
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è B≈ÇƒÖd testu audio:', error);
        }
    }

    /**
     * G≈Ç√≥wna metoda odtwarzania audio
     */
    async playAudio(text, options = {}, buttonSelector = null) {
        if (!text || this.isPlaying) {
            console.log('‚ö†Ô∏è Audio ju≈º odtwarzane lub brak tekstu');
            return false;
        }

        if (!this.isInitialized) {
            await this.initialize();
        }

        console.log(`üîä Pr√≥ba odtworzenia: "${text}"`);
        
        try {
            this.isPlaying = true;
            this.updateAudioButton('loading', AUDIO_CONFIG.ui.texts.loading, buttonSelector);

            let success = false;

            // 1. Najpierw pr√≥buj Speech Synthesis (najszybsze)
            if (this.engines.speechSynthesis) {
                console.log('üé§ Pr√≥bujƒô Speech Synthesis...');
                success = await this.engines.speechSynthesis.speak(text, {
                    ...options,
                    volume: this.volume,
                    rate: this.rate
                });
            }

            // 2. Je≈õli TTS nie dzia≈Ça, pr√≥buj Google TTS
            if (!success && this.engines.googleTTS) {
                console.log('üåê Pr√≥bujƒô Google TTS...');
                success = await this.engines.googleTTS.speak(text, {
                    ...options,
                    volume: this.volume
                });
            }

            // 3. Ostatnia szansa - ResponsiveVoice
            if (!success && this.engines.responsiveVoice) {
                console.log('üìª Pr√≥bujƒô ResponsiveVoice...');
                success = await this.engines.responsiveVoice.speak(text, {
                    ...options,
                    volume: this.volume,
                    rate: this.rate
                });
            }

            if (success) {
                this.updateAudioButton('success', AUDIO_CONFIG.ui.texts.playing, buttonSelector);
                this.notifySuccess();
            } else {
                throw new Error('Wszystkie metody audio nie powiod≈Çy siƒô');
            }

            return success;

        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd odtwarzania audio:', error);
            this.updateAudioButton('error', AUDIO_CONFIG.ui.texts.error, buttonSelector);
            this.notifyError();
            return false;

        } finally {
            // Reset po 3 sekundach
            setTimeout(() => {
                this.isPlaying = false;
                this.resetAudioButton(buttonSelector);
            }, 3000);
        }
    }

    /**
     * Odtwarzanie zdania przyk≈Çadowego
     */
    async playSentence(englishSentence, polishSentence = null) {
        console.log('üìù Odtwarzam zdanie przyk≈Çadowe...');
        
        if (!englishSentence) {
            console.warn('‚ö†Ô∏è Brak zdania do odtworzenia');
            return false;
        }

        return await this.playAudio(englishSentence, { 
            rate: 0.8, // Wolniej dla zda≈Ñ
            lang: 'en' 
        });
    }

    /**
     * Zatrzymanie odtwarzania
     */
    stopAudio() {
        console.log('‚èπÔ∏è Zatrzymujƒô audio...');
        
        // Zatrzymaj wszystkie silniki
        Object.values(this.engines).forEach(engine => {
            if (engine && typeof engine.stop === 'function') {
                engine.stop();
            }
        });
        
        this.currentAudio = null;
        this.isPlaying = false;
        this.resetAudioButton();
    }

    /**
     * Testowanie dostƒôpno≈õci audio
     */
    async testAudio() {
        console.log('üß™ Testowanie system√≥w audio...');
        
        const testText = "Hello, this is a test.";
        const results = {
            speechSynthesis: false,
            googleTTS: false,
            responsiveVoice: false
        };

        // Test Speech Synthesis
        if (this.engines.speechSynthesis) {
            try {
                results.speechSynthesis = await this.engines.speechSynthesis.speak(testText);
                console.log(`üé§ Speech Synthesis: ${results.speechSynthesis ? '‚úÖ' : '‚ùå'}`);
            } catch (e) {
                console.log('üé§ Speech Synthesis: ‚ùå');
            }
        }

        // Test Google TTS
        if (this.engines.googleTTS) {
            try {
                results.googleTTS = await this.engines.googleTTS.speak(testText);
                console.log(`üåê Google TTS: ${results.googleTTS ? '‚úÖ' : '‚ùå'}`);
            } catch (e) {
                console.log('üåê Google TTS: ‚ùå');
            }
        }

        // Test ResponsiveVoice
        if (this.engines.responsiveVoice) {
            try {
                results.responsiveVoice = await this.engines.responsiveVoice.speak(testText);
                console.log(`üìª ResponsiveVoice: ${results.responsiveVoice ? '‚úÖ' : '‚ùå'}`);
            } catch (e) {
                console.log('üìª ResponsiveVoice: ‚ùå');
            }
        }

        return results;
    }

    /**
     * Aktualizacja przycisku audio
     */
    updateAudioButton(state, text, targetSelector = null) {
        const config = AUDIO_CONFIG.ui;
        
        // Je≈õli podano konkretny selektor, aktualizuj tylko ten przycisk
        if (targetSelector) {
            const button = document.querySelector(targetSelector);
            if (button) {
                this.updateSingleButton(button, state, text, config);
            }
            return;
        }

        // Aktualizuj wszystkie przyciski audio
        const selectors = [config.selectors.audioBtn, config.selectors.sentenceAudioBtn];
        selectors.forEach(selector => {
            document.querySelectorAll(selector).forEach(btn => {
                this.updateSingleButton(btn, state, text, config);
            });
        });
    }

    /**
     * Aktualizacja pojedynczego przycisku
     */
    updateSingleButton(button, state, text, config) {
        // Usu≈Ñ poprzednie klasy stan√≥w
        Object.values(config.states).forEach(stateClass => {
            button.classList.remove(stateClass);
        });

        // Dodaj nowƒÖ klasƒô stanu
        if (state !== 'reset') {
            button.classList.add(config.states[state] || state);
        }

        button.textContent = text;
        button.disabled = (state === 'loading');
    }

    /**
     * Reset przycisku audio
     */
    resetAudioButton(targetSelector = null) {
        const config = AUDIO_CONFIG.ui;

        if (targetSelector) {
            const button = document.querySelector(targetSelector);
            if (button) {
                this.resetSingleButton(button, config);
            }
            return;
        }

        // Reset wszystkich przycisk√≥w
        const selectors = [config.selectors.audioBtn, config.selectors.sentenceAudioBtn];
        selectors.forEach(selector => {
            document.querySelectorAll(selector).forEach(btn => {
                this.resetSingleButton(btn, config);
            });
        });
    }

    /**
     * Reset pojedynczego przycisku
     */
    resetSingleButton(button, config) {
        // Usu≈Ñ klasy stan√≥w
        Object.values(config.states).forEach(stateClass => {
            button.classList.remove(stateClass);
        });

        // Ustaw odpowiedni tekst w zale≈ºno≈õci od typu przycisku
        if (button.classList.contains('sentence-audio-btn')) {
            button.textContent = config.texts.sentenceAudio;
        } else {
            button.textContent = config.texts.wordAudio;
        }
        
        button.disabled = false;
    }

    /**
     * Powiadomienia
     */
    notifySuccess() {
        if (typeof window !== 'undefined' && window.NotificationManager) {
            window.NotificationManager.show('Audio odtworzone pomy≈õlnie', 'success', 2000);
        }
    }

    notifyError() {
        if (typeof window !== 'undefined' && window.NotificationManager) {
            window.NotificationManager.show('Nie mo≈ºna odtworzyƒá audio', 'error');
        }
    }

    /**
     * Ustawienia
     */
    setAutoPlay(enabled) {
        this.autoPlay = enabled;
        console.log(`üîÑ AutoPlay: ${enabled ? 'w≈ÇƒÖczone' : 'wy≈ÇƒÖczone'}`);
    }

    setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));
        console.log(`üîä G≈Ço≈õno≈õƒá: ${Math.round(this.volume * 100)}%`);
    }

    setRate(rate) {
        this.rate = Math.max(0.1, Math.min(2, rate));
        console.log(`‚ö° Szybko≈õƒá: ${this.rate}`);
    }

    /**
     * Czyszczenie zasob√≥w
     */
    cleanup() {
        console.log('üßπ Czyszczenie AudioManager...');
        this.stopAudio();
        this.audioCache.clear();
        this.currentAudio = null;
        this.isPlaying = false;
        
        // Cleanup silnik√≥w
        Object.values(this.engines).forEach(engine => {
            if (engine && typeof engine.cleanup === 'function') {
                engine.cleanup();
            }
        });
    }
}

// Export jako domy≈õlny
export default AudioManager;

// Zachowanie kompatybilno≈õci z poprzedniƒÖ wersjƒÖ
if (typeof window !== 'undefined') {
    window.AudioManager = AudioManager;
    console.log('‚úÖ AudioManager (ES6) dostƒôpny globalnie dla kompatybilno≈õci');
}