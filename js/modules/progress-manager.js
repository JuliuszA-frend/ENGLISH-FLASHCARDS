/**
 * ProgressManager - Naprawione zarzƒÖdzanie postƒôpem
 * POPRAWIONA WERSJA z pe≈ÇnƒÖ obs≈ÇugƒÖ systemu trudno≈õci
 */
class ProgressManager {
    constructor() {
        this.vocabulary = null;
        this.storageKey = 'english-flashcards-progress';
        this.bookmarksKey = 'english-flashcards-bookmarks';
        this.difficultyKey = 'english-flashcards-difficulty';
    }

    /**
     * Ustawienie s≈Çownictwa - POPRAWIONE
     */
    setVocabulary(vocabulary) {
        this.vocabulary = vocabulary;
        
        // ‚úÖ NOWE: Logowanie do debugowania
        console.log('üìö ProgressManager otrzyma≈Ç s≈Çownictwo:', {
            categories: vocabulary?.categories ? Object.keys(vocabulary.categories).length : 0,
            structure: vocabulary?.categories ? 'OK' : 'B≈ÅƒÑD'
        });
        
        // ‚úÖ NOWE: Walidacja struktury danych
        if (!vocabulary || !vocabulary.categories) {
            console.error('‚ùå Nieprawid≈Çowa struktura s≈Çownictwa w ProgressManager');
            return false;
        }
        
        return true;
    }

    /**
     * Oznaczenie s≈Çowa jako przejrzane - POPRAWIONE
     */
    markWordAsStudied(category, wordIndex, wordId = null) {
        const progress = this.loadProgress();
        const cardId = wordId || `${category}-${wordIndex}`;
        
        if (!progress.studiedCards.includes(cardId)) {
            progress.studiedCards.push(cardId);
            progress.lastStudied = new Date().toISOString();
            
            // ‚úÖ POPRAWKA: U≈ºyj poprawionej funkcji getCategoryWordCount
            if (!progress.categoryStats[category]) {
                progress.categoryStats[category] = {
                    studied: 0,
                    total: this.getCategoryWordCount(category), // Teraz dzia≈Ça prawid≈Çowo
                    lastAccess: new Date().toISOString()
                };
            }
            
            progress.categoryStats[category].studied++;
            progress.categoryStats[category].lastAccess = new Date().toISOString();
            
            // ‚úÖ NOWE: Aktualizuj total na wypadek zmiany w s≈Çownictwie
            progress.categoryStats[category].total = this.getCategoryWordCount(category);
            
            // Aktualizuj daty nauki
            this.updateStudyDates(progress);
            
            this.saveProgress(progress);
            
            // ‚úÖ NOWE: Logowanie dla debugowania
            console.log(`üìà S≈Çowo oznaczone jako nauczone: ${cardId}`, {
                category: category,
                studied: progress.categoryStats[category].studied,
                total: progress.categoryStats[category].total
            });
            
            return true;
        }
        
        return false;
    }

    /**
     * Pobranie postƒôpu kategorii - POPRAWIONE i ROZSZERZONE
     */
    getCategoryProgress(category) {
        const progress = this.loadProgress();
        const categoryStats = progress.categoryStats[category];
        
        // ‚úÖ POPRAWKA: Zawsze u≈ºyj aktualnej liczby s≈Ç√≥w z s≈Çownictwa
        const currentTotal = this.getCategoryWordCount(category);
        
        if (categoryStats) {
            // ‚úÖ POPRAWKA: Aktualizuj total je≈õli siƒô zmieni≈Ç
            if (categoryStats.total !== currentTotal) {
                categoryStats.total = currentTotal;
                this.saveProgress(progress);
            }
            
            const studied = categoryStats.studied;
            const total = currentTotal;
            const percentage = total > 0 ? Math.round((studied / total) * 100) : 0;
            
            return {
                studied: studied,
                total: total,
                percentage: percentage
            };
        }
        
        // ‚úÖ POPRAWKA: Je≈õli brak statystyk, zwr√≥ƒá aktualne dane
        return {
            studied: 0,
            total: currentTotal,
            percentage: 0
        };
    }

    /**
     * ‚úÖ G≈Å√ìWNA POPRAWKA: Prawid≈Çowe liczenie s≈Ç√≥w w kategorii
     */
    getCategoryWordCount(category) {
        // ‚úÖ POPRAWKA: Sprawd≈∫ strukturƒô vocabulary.categories zamiast vocabulary
        if (!this.vocabulary || !this.vocabulary.categories || !this.vocabulary.categories[category]) {
            console.warn(`‚ö†Ô∏è Brak kategorii: ${category} w s≈Çownictwie`);
            return 0;
        }
        
        // ‚úÖ POPRAWKA: Dostƒôp przez categories[category].words
        const categoryData = this.vocabulary.categories[category];
        
        if (!categoryData.words || !Array.isArray(categoryData.words)) {
            console.warn(`‚ö†Ô∏è Kategoria ${category} nie ma tablicy s≈Ç√≥w`);
            return 0;
        }
        
        const wordCount = categoryData.words.length;
        
        // ‚úÖ NOWE: Logowanie dla debugowania
        console.log(`üìä Liczba s≈Ç√≥w w kategorii ${category}: ${wordCount}`);
        
        return wordCount;
    }

    /**
     * Pobranie og√≥lnych statystyk - POPRAWIONE
     */
    getOverallStats() {
        const progress = this.loadProgress();
        const totalWords = this.getTotalWordCount();
        const studiedCount = progress.studiedCards.length;
        const studyStreak = this.calculateStudyStreak(progress.studyDates);
        const favoriteCategory = this.getFavoriteCategory(progress);
        
        return {
            totalStudied: studiedCount,
            totalWords: totalWords,
            studyStreak: studyStreak,
            favoriteCategory: favoriteCategory,
            studiedPercentage: totalWords > 0 ? Math.round((studiedCount / totalWords) * 100) : 0
        };
    }

    /**
     * ‚úÖ POPRAWKA: Prawid≈Çowe liczenie wszystkich s≈Ç√≥w
     */
    getTotalWordCount() {
        if (!this.vocabulary || !this.vocabulary.categories) {
            return 0;
        }
        
        // ‚úÖ POPRAWKA: Iteruj przez vocabulary.categories
        let totalWords = 0;
        
        Object.values(this.vocabulary.categories).forEach(category => {
            if (category.words && Array.isArray(category.words)) {
                totalWords += category.words.length;
            }
        });
        
        console.log(`üìö ≈ÅƒÖczna liczba s≈Ç√≥w: ${totalWords}`);
        return totalWords;
    }

    /**
     * ‚úÖ NOWA METODA: Resetowanie postƒôpu kategorii (dla debugowania)
     */
    resetCategory(categoryKey) {
        const progress = this.loadProgress();
        
        if (progress.categoryStats[categoryKey]) {
            // Usu≈Ñ s≈Çowa tej kategorii z przejrzanych
            const categoryPrefix = `${categoryKey}-`;
            progress.studiedCards = progress.studiedCards.filter(cardId => 
                !cardId.startsWith(categoryPrefix)
            );
            
            // Resetuj statystyki kategorii
            delete progress.categoryStats[categoryKey];
            
            this.saveProgress(progress);
            
            console.log(`üîÑ Zresetowano postƒôp kategorii: ${categoryKey}`);
            return true;
        }
        
        return false;
    }

    /**
     * ‚úÖ NOWA METODA: Diagnostyka kategorii (do debugowania)
     */
    debugCategory(category) {
        console.group(`üîç Diagnostyka kategorii: ${category}`);
        
        // Sprawd≈∫ dostƒôpno≈õƒá s≈Çownictwa
        console.log('üìö S≈Çownictwo dostƒôpne:', !!this.vocabulary);
        console.log('üìÇ Categories dostƒôpne:', !!this.vocabulary?.categories);
        console.log('üìÅ Kategoria dostƒôpna:', !!this.vocabulary?.categories?.[category]);
        
        if (this.vocabulary?.categories?.[category]) {
            const categoryData = this.vocabulary.categories[category];
            console.log('üìÑ Dane kategorii:', {
                name: categoryData.name,
                hasWords: !!categoryData.words,
                wordsCount: categoryData.words?.length || 0,
                wordsIsArray: Array.isArray(categoryData.words)
            });
        }
        
        // Sprawd≈∫ postƒôp
        const progress = this.getCategoryProgress(category);
        console.log('üìà Postƒôp kategorii:', progress);
        
        console.groupEnd();
        
        return {
            vocabularyAvailable: !!this.vocabulary,
            categoryAvailable: !!this.vocabulary?.categories?.[category],
            wordCount: this.getCategoryWordCount(category),
            progress: progress
        };
    }

    /**
     * ‚úÖ NOWA METODA: Aktualizacja wszystkich statystyk kategorii
     */
    updateAllCategoryStats() {
        if (!this.vocabulary || !this.vocabulary.categories) {
            console.warn('‚ö†Ô∏è Brak s≈Çownictwa do aktualizacji statystyk');
            return false;
        }
        
        const progress = this.loadProgress();
        let updated = false;
        
        // Sprawd≈∫ wszystkie kategorie
        Object.keys(this.vocabulary.categories).forEach(categoryKey => {
            const currentTotal = this.getCategoryWordCount(categoryKey);
            
            if (progress.categoryStats[categoryKey]) {
                // Aktualizuj istniejƒÖce statystyki je≈õli total siƒô zmieni≈Ç
                if (progress.categoryStats[categoryKey].total !== currentTotal) {
                    progress.categoryStats[categoryKey].total = currentTotal;
                    updated = true;
                    console.log(`üìä Zaktualizowano total dla ${categoryKey}: ${currentTotal}`);
                }
            }
        });
        
        if (updated) {
            this.saveProgress(progress);
            console.log('‚úÖ Statystyki kategorii zaktualizowane');
        }
        
        return updated;
    }

    /**
     * ‚ú® NAPRAWIONA METODA: Toggle trudno≈õci s≈Çowa z pe≈ÇnƒÖ obs≈ÇugƒÖ i logowaniem
     */
    toggleWordDifficulty(word) {
        console.log(`‚≠ê toggleWordDifficulty wywo≈Çane dla s≈Çowa: ${word.english}`);
        
        try {
            // üìä Za≈Çaduj aktualny stan trudno≈õci
            const difficulty = this.loadDifficulty();
            const wordKey = this.getWordKey(word);
            
            console.log(`üîë WordKey: ${wordKey}`);
            
            // üìà Dostƒôpne poziomy trudno≈õci
            const levels = ['easy', 'medium', 'hard'];
            
            // üìä Znajd≈∫ aktualny poziom
            const currentLevel = difficulty[wordKey] || word.difficulty || 'medium';
            console.log(`üìä Aktualny poziom: ${currentLevel}`);
            
            // üîÑ Oblicz nastƒôpny poziom (cyklicznie)
            const currentIndex = levels.indexOf(currentLevel);
            const nextIndex = (currentIndex + 1) % levels.length;
            const newLevel = levels[nextIndex];
            
            console.log(`üîÑ Prze≈ÇƒÖczam z ${currentLevel} (index: ${currentIndex}) na ${newLevel} (index: ${nextIndex})`);
            
            // üíæ Zapisz nowy poziom
            difficulty[wordKey] = newLevel;
            this.saveDifficulty(difficulty);
            
            console.log(`‚úÖ Trudno≈õƒá zapisana: ${wordKey} ‚Üí ${newLevel}`);
            
            // üìä Wyloguj stan po zapisie (weryfikacja)
            const verificationDifficulty = this.loadDifficulty();
            const savedLevel = verificationDifficulty[wordKey];
            console.log(`üîç Weryfikacja zapisu: ${savedLevel} (oczekiwano: ${newLevel})`);
            
            if (savedLevel !== newLevel) {
                console.error(`‚ùå B≈ÅƒÑD: Poziom nie zosta≈Ç poprawnie zapisany! Saved: ${savedLevel}, Expected: ${newLevel}`);
            }
            
            return newLevel;
            
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd w toggleWordDifficulty:', error);
            console.error('‚ùå Stack trace:', error.stack);
            
            // Fallback - zwr√≥ƒá aktualny poziom lub domy≈õlny
            const fallbackLevel = word.difficulty || 'medium';
            console.log(`üîÑ Fallback: zwracam ${fallbackLevel}`);
            return fallbackLevel;
        }
    }

    /**
     * ‚ú® NOWA METODA: Pobieranie poziomu trudno≈õci s≈Çowa (dla UI)
     */
    getWordDifficulty(word) {
        try {
            const difficulty = this.loadDifficulty();
            const wordKey = this.getWordKey(word);
            const level = difficulty[wordKey] || word.difficulty || 'medium';
            
            console.log(`üîç getWordDifficulty dla ${word.english}: ${level}`);
            return level;
            
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd podczas pobierania trudno≈õci:', error);
            return word.difficulty || 'medium';
        }
    }

    /**
     * ‚ú® NOWA METODA: Ustawienie poziomu trudno≈õci s≈Çowa (bezpo≈õrednie)
     */
    setWordDifficulty(word, difficultyLevel) {
        const validLevels = ['easy', 'medium', 'hard'];
        
        if (!validLevels.includes(difficultyLevel)) {
            console.error(`‚ùå Nieprawid≈Çowy poziom trudno≈õci: ${difficultyLevel}`);
            return false;
        }
        
        try {
            const difficulty = this.loadDifficulty();
            const wordKey = this.getWordKey(word);
            
            console.log(`‚≠ê setWordDifficulty: ${word.english} ‚Üí ${difficultyLevel}`);
            
            difficulty[wordKey] = difficultyLevel;
            this.saveDifficulty(difficulty);
            
            console.log(`‚úÖ Poziom trudno≈õci ustawiony: ${wordKey} ‚Üí ${difficultyLevel}`);
            return true;
            
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd podczas ustawiania trudno≈õci:', error);
            return false;
        }
    }

    /**
     * ‚ú® NOWA METODA: Statystyki trudno≈õci
     */
    getDifficultyStats() {
        try {
            const difficulty = this.loadDifficulty();
            const stats = {
                easy: 0,
                medium: 0,
                hard: 0,
                total: 0
            };
            
            Object.values(difficulty).forEach(level => {
                if (stats.hasOwnProperty(level)) {
                    stats[level]++;
                    stats.total++;
                }
            });
            
            console.log('üìä Statystyki trudno≈õci:', stats);
            return stats;
            
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd podczas pobierania statystyk trudno≈õci:', error);
            return { easy: 0, medium: 0, hard: 0, total: 0 };
        }
    }

    /**
     * ‚ú® NOWA METODA: Reset wszystkich poziom√≥w trudno≈õci
     */
    resetAllDifficulties() {
        try {
            console.log('üîÑ Resetujƒô wszystkie poziomy trudno≈õci...');
            
            const emptyDifficulty = {};
            this.saveDifficulty(emptyDifficulty);
            
            console.log('‚úÖ Wszystkie poziomy trudno≈õci zresetowane');
            return true;
            
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd podczas resetowania trudno≈õci:', error);
            return false;
        }
    }

    toggleWordBookmark(word) {
        const bookmarks = this.loadBookmarks();
        const wordKey = this.getWordKey(word);
        
        if (bookmarks.includes(wordKey)) {
            // ‚ûñ Usu≈Ñ z bookmarks
            const index = bookmarks.indexOf(wordKey);
            bookmarks.splice(index, 1);
            
            // üóëÔ∏è Usu≈Ñ datƒô
            const bookmarkDates = this.loadBookmarkDates();
            delete bookmarkDates[wordKey];
            this.saveBookmarkDates(bookmarkDates);
            
            console.log(`‚ûñ Usuniƒôto bookmark: ${wordKey}`);
        } else {
            // ‚ûï Dodaj do bookmarks
            bookmarks.push(wordKey);
            
            // üìÖ Zapisz datƒô dodania
            this.saveBookmarkDate(wordKey);
            
            console.log(`‚ûï Dodano bookmark: ${wordKey}`);
        }
        
        // üíæ Zapisz zaktualizowane bookmarks
        this.saveBookmarks(bookmarks);
        
        // üìä Zwr√≥ƒá nowy stan (true = jest w bookmarks)
        const isBookmarked = bookmarks.includes(wordKey);
        return isBookmarked;
    }

    isWordBookmarked(word) {
        const bookmarks = this.loadBookmarks();
        const wordKey = this.getWordKey(word);
        return bookmarks.includes(wordKey);
    }

    getWordKey(word) {
        // üîß STARA WERSJA (problematyczna):
        // return word.id || `${word.english}-${word.polish}`;
        
        // ‚úÖ NOWA WERSJA - zawsze unikalny klucz:
        // U≈ºywa kombinacji angielskiego s≈Çowa i polskiego t≈Çumaczenia
        // co gwarantuje unikalno≈õƒá nawet je≈õli ID sƒÖ duplikowane
        return `${word.english.toLowerCase().trim()}-${word.polish.toLowerCase().trim()}`;
    }

    loadProgress() {
        try {
            const data = localStorage.getItem(this.storageKey);
            if (data) {
                return JSON.parse(data);
            }
        } catch (error) {
            console.error('B≈ÇƒÖd ≈Çadowania postƒôpu:', error);
        }
        
        return this.getDefaultProgress();
    }

    saveProgress(progress) {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(progress));
        } catch (error) {
            console.error('B≈ÇƒÖd zapisywania postƒôpu:', error);
        }
    }

    getDefaultProgress() {
        return {
            studiedCards: [],
            studyDates: [],
            categoryStats: {},
            lastStudied: null,
            version: '1.0.0'
        };
    }

    getAllBookmarkedWords() {
        const bookmarks = this.loadBookmarks();
        const bookmarkedWords = [];
        
        // üîç Sprawd≈∫ czy mamy dostƒôp do s≈Çownictwa
        if (!this.vocabulary || !this.vocabulary.categories) {
            console.warn('‚ö†Ô∏è Brak dostƒôpu do s≈Çownictwa w getAllBookmarkedWords');
            return [];
        }
        
        // üìö Przejd≈∫ przez wszystkie kategorie i znajd≈∫ ulubione s≈Çowa
        Object.entries(this.vocabulary.categories).forEach(([categoryKey, category]) => {
            if (category.words && Array.isArray(category.words)) {
                category.words.forEach((word, index) => {
                    const wordKey = this.getWordKey(word);
                    
                    // ‚úÖ Je≈õli s≈Çowo jest w bookmarks, dodaj je z dodatkowymi info
                    if (bookmarks.includes(wordKey)) {
                        bookmarkedWords.push({
                            ...word, // Wszystkie dane s≈Çowa
                            categoryKey: categoryKey,
                            categoryName: category.name,
                            categoryIcon: category.icon || 'üìö',
                            wordIndex: index,
                            wordKey: wordKey,
                            bookmarkedAt: this.getBookmarkDate(wordKey) // Kiedy dodano do ulubionych
                        });
                    }
                });
            }
        });
        
        // üìä Sortuj wed≈Çug daty dodania (najnowsze pierwsze)
        bookmarkedWords.sort((a, b) => {
            const dateA = new Date(a.bookmarkedAt || 0);
            const dateB = new Date(b.bookmarkedAt || 0);
            return dateB - dateA;
        });
        
        console.log(`üîñ Znaleziono ${bookmarkedWords.length} ulubionych s≈Ç√≥w`);
        return bookmarkedWords;
    }

    /**
     * ‚ú® NOWA METODA: Pobranie ulubionych s≈Ç√≥w z konkretnej kategorii
     */
    getBookmarkedWordsFromCategory(categoryKey) {
        const allBookmarked = this.getAllBookmarkedWords();
        const categoryBookmarks = allBookmarked.filter(word => word.categoryKey === categoryKey);
        
        console.log(`üîñ Kategoria ${categoryKey}: ${categoryBookmarks.length} ulubionych s≈Ç√≥w`);
        return categoryBookmarks;
    }

    /**
     * ‚ú® NOWA METODA: Statystyki bookmarks
     */
    getBookmarkStats() {
        const bookmarks = this.loadBookmarks();
        const bookmarkedWords = this.getAllBookmarkedWords();
        
        // üìä Policz ulubione w ka≈ºdej kategorii
        const categoryStats = {};
        bookmarkedWords.forEach(word => {
            if (!categoryStats[word.categoryKey]) {
                categoryStats[word.categoryKey] = {
                    count: 0,
                    categoryName: word.categoryName,
                    categoryIcon: word.categoryIcon
                };
            }
            categoryStats[word.categoryKey].count++;
        });
        
        // üèÜ Znajd≈∫ kategoriƒô z najwiƒôkszƒÖ liczbƒÖ ulubionych
        let topCategory = null;
        let maxCount = 0;
        Object.entries(categoryStats).forEach(([key, stats]) => {
            if (stats.count > maxCount) {
                maxCount = stats.count;
                topCategory = {
                    key: key,
                    name: stats.categoryName,
                    count: stats.count
                };
            }
        });
        
        return {
            totalBookmarks: bookmarks.length,
            totalCategories: Object.keys(categoryStats).length,
            categoryStats: categoryStats,
            topCategory: topCategory,
            recentlyAdded: bookmarkedWords.slice(0, 5) // Ostatnie 5 dodanych
        };
    }

    /**
     * ‚ú® NOWA METODA: Export ulubionych do JSON
     */
    exportBookmarks() {
        const bookmarkedWords = this.getAllBookmarkedWords();
        const stats = this.getBookmarkStats();
        
        const exportData = {
            metadata: {
                exportDate: new Date().toISOString(),
                totalBookmarks: stats.totalBookmarks,
                version: '1.0.0',
                appName: 'English Flashcards B1/B2'
            },
            bookmarks: bookmarkedWords,
            statistics: stats
        };
        
        console.log('üì§ Przygotowano dane do eksportu:', exportData);
        return exportData;
    }

    /**
     * ‚ú® NOWA METODA: Import ulubionych z JSON
     */
    importBookmarks(importData) {
        try {
            // üîç Walidacja danych
            if (!importData || !importData.bookmarks || !Array.isArray(importData.bookmarks)) {
                throw new Error('Nieprawid≈Çowy format danych import');
            }
            
            // üìù WyciƒÖgnij wordKey z importowanych s≈Ç√≥w
            const importedWordKeys = importData.bookmarks.map(word => 
                word.wordKey || this.getWordKey(word)
            );
            
            // üîÑ Zamie≈Ñ obecne bookmarks na importowane
            this.saveBookmarks(importedWordKeys);
            
            // üíæ Zapisz r√≥wnie≈º daty bookmarks je≈õli dostƒôpne
            if (importData.bookmarks.some(word => word.bookmarkedAt)) {
                const bookmarkDates = {};
                importData.bookmarks.forEach(word => {
                    if (word.bookmarkedAt) {
                        const wordKey = word.wordKey || this.getWordKey(word);
                        bookmarkDates[wordKey] = word.bookmarkedAt;
                    }
                });
                this.saveBookmarkDates(bookmarkDates);
            }
            
            console.log(`‚úÖ Zaimportowano ${importedWordKeys.length} ulubionych s≈Ç√≥w`);
            return {
                success: true,
                imported: importedWordKeys.length
            };
            
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd importu bookmarks:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * ‚ú® NOWA METODA: Usuniƒôcie wszystkich bookmarks
     */
    clearAllBookmarks() {
        const bookmarksCount = this.loadBookmarks().length;
        
        // üóëÔ∏è Wyczy≈õƒá bookmarks
        this.saveBookmarks([]);
        
        // üóëÔ∏è Wyczy≈õƒá daty bookmarks
        this.saveBookmarkDates({});
        
        console.log(`üóëÔ∏è Usuniƒôto ${bookmarksCount} ulubionych s≈Ç√≥w`);
        return bookmarksCount;
    }

    /**
     * ‚ú® NOWA METODA: Zapisanie daty dodania bookmark
     */
    saveBookmarkDate(wordKey) {
        const bookmarkDates = this.loadBookmarkDates();
        bookmarkDates[wordKey] = new Date().toISOString();
        this.saveBookmarkDates(bookmarkDates);
    }

    /**
     * ‚ú® NOWA METODA: Pobranie daty dodania bookmark
     */
    getBookmarkDate(wordKey) {
        const bookmarkDates = this.loadBookmarkDates();
        return bookmarkDates[wordKey] || null;
    }

    /**
     * ‚ú® NOWA METODA: ≈Åadowanie dat bookmarks
     */
    loadBookmarkDates() {
        try {
            const data = localStorage.getItem(this.bookmarksKey + '-dates');
            return data ? JSON.parse(data) : {};
        } catch (error) {
            console.error('B≈ÇƒÖd ≈Çadowania dat bookmarks:', error);
            return {};
        }
    }

    /**
     * ‚ú® NOWA METODA: Zapisywanie dat bookmarks
     */
    saveBookmarkDates(dates) {
        try {
            localStorage.setItem(this.bookmarksKey + '-dates', JSON.stringify(dates));
        } catch (error) {
            console.error('B≈ÇƒÖd zapisywania dat bookmarks:', error);
        }
    }

    loadBookmarks() {
        try {
            const data = localStorage.getItem(this.bookmarksKey);
            return data ? JSON.parse(data) : [];
        } catch (error) {
            console.error('B≈ÇƒÖd ≈Çadowania bookmarks:', error);
            return [];
        }
    }

    saveBookmarks(bookmarks) {
        try {
            localStorage.setItem(this.bookmarksKey, JSON.stringify(bookmarks));
        } catch (error) {
            console.error('B≈ÇƒÖd zapisywania bookmarks:', error);
        }
    }

    /**
     * ‚ú® NAPRAWIONE METODY: ≈Åadowanie i zapisywanie trudno≈õci z logowaniem
     */
    loadDifficulty() {
        try {
            const data = localStorage.getItem(this.difficultyKey);
            const difficulty = data ? JSON.parse(data) : {};
            
            console.log(`üìä Za≈Çadowano ${Object.keys(difficulty).length} poziom√≥w trudno≈õci z localStorage`);
            
            return difficulty;
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd ≈Çadowania poziom√≥w trudno≈õci:', error);
            return {};
        }
    }

    saveDifficulty(difficulty) {
        try {
            const serialized = JSON.stringify(difficulty);
            localStorage.setItem(this.difficultyKey, serialized);
            
            console.log(`üíæ Zapisano ${Object.keys(difficulty).length} poziom√≥w trudno≈õci do localStorage`);
            console.log('üíæ Przyk≈Çad zapisanych danych:', Object.fromEntries(Object.entries(difficulty).slice(0, 3)));
            
            // ‚úÖ WERYFIKACJA ZAPISU
            const verification = localStorage.getItem(this.difficultyKey);
            if (verification === serialized) {
                console.log('‚úÖ Weryfikacja zapisu trudno≈õci: SUKCES');
            } else {
                console.error('‚ùå Weryfikacja zapisu trudno≈õci: B≈ÅƒÑD');
                console.error('‚ùå Oczekiwano:', serialized);
                console.error('‚ùå Otrzymano:', verification);
            }
            
        } catch (error) {
            console.error('‚ùå B≈ÇƒÖd zapisywania poziom√≥w trudno≈õci:', error);
            console.error('‚ùå Dane do zapisu:', difficulty);
        }
    }

    updateStudyDates(progress) {
        const today = new Date().toISOString().split('T')[0];
        if (!progress.studyDates.includes(today)) {
            progress.studyDates.push(today);
            if (progress.studyDates.length > 365) {
                progress.studyDates = progress.studyDates.slice(-365);
            }
        }
    }

    calculateStudyStreak(studyDates) {
        if (!studyDates || studyDates.length === 0) return 0;
        
        const today = new Date();
        let streak = 0;
        let currentDate = new Date(today);
        
        for (let i = studyDates.length - 1; i >= 0; i--) {
            const studyDate = new Date(studyDates[i]);
            const daysDiff = Math.floor((currentDate - studyDate) / (1000 * 60 * 60 * 24));
            
            if (daysDiff === streak) {
                streak++;
            } else {
                break;
            }
            
            currentDate.setDate(currentDate.getDate() - 1);
        }
        
        return streak;
    }

    getFavoriteCategory(progress) {
        const categoryStats = progress.categoryStats;
        if (!categoryStats || Object.keys(categoryStats).length === 0) {
            return null;
        }
        
        let maxStudied = 0;
        let favoriteCategory = null;
        
        for (const [category, stats] of Object.entries(categoryStats)) {
            if (stats.studied > maxStudied) {
                maxStudied = stats.studied;
                favoriteCategory = category;
            }
        }
        
        return favoriteCategory;
    }

    exportData() {
        return {
            progress: this.loadProgress(),
            bookmarks: this.loadBookmarks(),
            difficulty: this.loadDifficulty()
        };
    }

    importData(data) {
        if (data.progress) {
            this.saveProgress(data.progress);
        }
        if (data.bookmarks) {
            this.saveBookmarks(data.bookmarks);
        }
        if (data.difficulty) {
            this.saveDifficulty(data.difficulty);
        }
    }

    reset() {
        localStorage.removeItem(this.storageKey);
        localStorage.removeItem(this.bookmarksKey);
        localStorage.removeItem(this.difficultyKey);
        localStorage.removeItem(this.bookmarksKey + '-dates'); // ‚ú® NOWE: usu≈Ñ tak≈ºe daty
        console.log('üîÑ ProgressManager zresetowany');
    }
}

// Export dla modu≈Ç√≥w
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ProgressManager;
}